/*drop SCHEMA public cascade;
create schema public;*/
create EXTENSION IF NOT EXISTS postgis;
create SCHEMA IF NOT EXISTS import_data;
CREATE SCHEMA IF NOT EXISTS geotools;
create schema IF NOT EXISTS config;
CREATE SCHEMA IF NOT EXISTS results_export;

CREATE SEQUENCE geotools.global_seq;
CREATE SEQUENCE geotools.pt_seq;
CREATE SEQUENCE geotools.line_seq;
CREATE SEQUENCE geotools.polygon_seq;

--Revision table
CREATE TABLE IF NOT EXISTS geotools.revisions(
  objectid SERIAL PRIMARY KEY ,
  rev text UNIQUE NOT NULL ,
  desciption text NOT NULL ,
  active BOOLEAN
);
create unique index on geotools.revisions (active)
where active = true;
INSERT INTO geotools.revisions (rev, desciption, active) VALUES ('base','Autogenerated revision',TRUE);


-- Location Table
DROP TABLE IF EXISTS geotools.loc CASCADE;
CREATE TABLE geotools.loc (
    objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.polygon_seq'),
    name_id text UNIQUE
      CONSTRAINT validate_name_id CHECK (name_id similar to '[\d_a-z]{1,}')
      NOT NULL ,
    name_id_list text[] CONSTRAINT loc_in_other_loc CHECK ( name_id_list && ARRAY[name_id]) NOT NULL ,
    fk_objectid BIGINT
       REFERENCES geotools.loc (objectid) ON DELETE CASCADE ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED,
    lbl text NOT NULL ,
    loc_type text NOT NULL ,
    hh numeric NOT NULL DEFAULT -1,
    pop numeric NOT NULL DEFAULT -1,
    original_record jsonb,
    geom geometry(polygon,3857)
);

CREATE INDEX  ON geotools.loc USING GIN (name_id_list);
CREATE INDEX  ON geotools.loc (fk_objectid);
CREATE INDEX  ON geotools.loc (lbl);
CREATE INDEX  ON geotools.loc (loc_type);
CREATE INDEX  ON geotools.loc (hh);
CREATE INDEX  ON geotools.loc (pop);
CREATE INDEX  ON geotools.loc USING GIN (original_record jsonb_ops);
CREATE INDEX  ON geotools.loc USING GIN (original_record jsonb_path_ops);
CREATE INDEX  ON geotools.loc using gist (geom);

DROP MATERIALIZED VIEW IF EXISTS geotools.mvw_loc ;
CREATE MATERIALIZED VIEW geotools.mvw_loc as
with q10 as(
  SELECT
  objectid parent_objectid,
  name_id,
  name_id_list,
  fk_objectid,
  lbl,
  loc_type,
  hh,
  pop,
  (ST_Subdivide(geom))::geometry(polygon,3857) geom
FROM geotools.loc)
select   row_number() over() objectid, q10.* from q10;

CREATE UNIQUE INDEX ON geotools.mvw_loc (objectid);
CREATE INDEX  ON geotools.mvw_loc (parent_objectid);
CREATE INDEX  ON geotools.mvw_loc (name_id);
CREATE INDEX  ON geotools.mvw_loc USING GIN (name_id_list);
CREATE INDEX  ON geotools.mvw_loc (fk_objectid);
CREATE INDEX  ON geotools.mvw_loc (lbl);
CREATE INDEX  ON geotools.mvw_loc (loc_type);
CREATE INDEX  ON geotools.mvw_loc (hh);
CREATE INDEX  ON geotools.mvw_loc (pop);
CREATE INDEX  ON geotools.mvw_loc using gist (geom);

--############## Existing Transfomers #######################################
DROP TABLE IF EXISTS  geotools.dtr;
CREATE TABLE geotools.dtr (
    objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.pt_seq'),
    loc text NOT NULL DEFAULT 'unk',
    loc_list text[] CONSTRAINT loc_in_other_loc CHECK ( loc_list && ARRAY[loc])DEFAULT array['unk'],
    kva numeric,
    original_record jsonb,
    geom geometry(point,3857) UNIQUE
);
CREATE INDEX  ON geotools.dtr  (loc);
CREATE INDEX  ON geotools.dtr  using GIN (loc_list);
CREATE INDEX  ON geotools.dtr USING gist (geom);
CREATE INDEX  ON geotools.dtr USING GIN (original_record jsonb_ops);
CREATE INDEX  ON geotools.dtr USING GIN (original_record jsonb_path_ops);


--Buildings table
DROP TABLE IF EXISTS  geotools.bldgs cascade;
CREATE TABLE IF NOT EXISTS geotools.bldgs (
    objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.pt_seq'),
    loc text NOT NULL DEFAULT 'unk',
    loc_list text[] CONSTRAINT loc_in_other_loc CHECK ( loc_list && ARRAY[loc])DEFAULT array['unk'],
    proj text NOT NULL DEFAULT 'unk' ,
    rev text NOT NULL DEFAULT 'base',
    hhr  numeric NOT NULL DEFAULT 1 ,
    cl_id text NOT NULL DEFAULT 'unk' ,
    sts text NOT NULL DEFAULT 'unk' ,
    adj_cnt numeric NOT NULL DEFAULT -1,
    adj_cnt_dist numeric NOT NULL DEFAULT -1,
    original_record jsonb,
    geom geometry(point,3857) NOT NULL ,
    snap_geom geometry(point,3857) NOT NULL
);

CREATE INDEX  ON geotools.bldgs  (hhr);
CREATE INDEX  ON geotools.bldgs  (loc);
CREATE INDEX  ON geotools.bldgs  (proj);
CREATE INDEX  ON geotools.bldgs using GIN (loc_list);
CREATE INDEX  ON geotools.bldgs  (cl_id);
CREATE INDEX  ON geotools.bldgs  (rev);
CREATE INDEX  ON geotools.bldgs  (sts);
CREATE INDEX  ON geotools.bldgs  (adj_cnt);
CREATE INDEX  ON geotools.bldgs  (adj_cnt_dist);
CREATE INDEX  ON geotools.bldgs  USING GIN (original_record jsonb_ops);
CREATE INDEX  ON geotools.bldgs  USING GIN (original_record jsonb_path_ops);
CREATE UNIQUE INDEX  ON geotools.bldgs  (rev,geom);
CREATE INDEX  ON geotools.bldgs USING gist (geom);
CREATE INDEX  ON geotools.bldgs USING gist (snap_geom);

-- cluster table
DROP  TABLE IF EXISTS geotools.bldgs_cl CASCADE;
CREATE TABLE geotools.bldgs_cl (
    objectid BIGINT PRIMARY KEY DEFERRABLE ,
    cl_id text,
    loc text,
    loc_list text[],
    proj text,
    rev text,
    b_cnt numeric,
    hh_cnt numeric,
    demand numeric,
    dist numeric,
    tr_size text,
    v_level text,
    phase text,
    voltage text,
    ce_geom geometry(point,3857),
    hull_geom geometry(polygon,3857),
    ver_geom geometry(polygon,3857)
);

--ALTER TABLE geotools.bldgs_cl ADD CONSTRAINT bldgs_cl_objectid_pk PRIMARY KEY (objectid) DEFERRABLE ;

CREATE UNIQUE INDEX  ON geotools.bldgs_cl (cl_id);
CREATE INDEX  ON geotools.bldgs_cl (loc);
CREATE INDEX  ON geotools.bldgs_cl using gin(loc_list);
CREATE INDEX  ON geotools.bldgs_cl (proj);
CREATE INDEX  ON geotools.bldgs_cl (rev);
CREATE INDEX  ON geotools.bldgs_cl (hh_cnt);

CREATE INDEX  ON geotools.bldgs_cl USING gist (hull_geom);
CREATE INDEX  ON geotools.bldgs_cl USING gist (ce_geom);
CREATE INDEX  ON geotools.bldgs_cl USING gist (ver_geom);
--/////////////////////////////////////////////////////////////////////////////////////////
DROP TABLE IF EXISTS geotools.nodes;
CREATE TABLE geotools.nodes (
    objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.pt_seq') ,
    loc text,
    rev text,
    proj text,
    hh_cnt numeric,
    b_cnt numeric,
    cl_id text,
    node_type text,
    cu text,
    geom geometry(point,3857)
);
CREATE INDEX  ON geotools.nodes  (cl_id);
CREATE INDEX  ON geotools.nodes  (loc);
CREATE INDEX  ON geotools.nodes  (rev);
CREATE INDEX  ON geotools.nodes  (proj);
CREATE INDEX  ON geotools.nodes  (hh_cnt);
CREATE INDEX  ON geotools.nodes  (b_cnt);
CREATE INDEX  ON geotools.nodes  (node_type);
CREATE INDEX  ON geotools.nodes  (cu);
CREATE unique INDEX  ON geotools.nodes  (geom,rev);
CREATE INDEX  ON geotools.nodes  USING gist (geom);
--#######################################

--#######################################
CREATE TABLE geotools.prj
(
    objectid BIGINT PRIMARY KEY,
    src_id BIGINT[] NOT NULL,
    loc TEXT,
    loc_list TEXT[],
    n_tr INTEGER,
    t_cost NUMERIC,

    geom geometry(polygon,3857)
);

--#######################################

DROP TABLE IF EXISTS geotools.lines;
CREATE TABLE geotools.lines (
    objectid BIGSERIAL PRIMARY KEY,
    loc text[],
    sub text,
    fd text,
    volt text,
      original_record jsonb,
    geom geometry(linestring,3857)
);
CREATE INDEX  ON geotools.lines USING GIN (original_record jsonb_ops);
CREATE INDEX  ON geotools.lines USING GIN (original_record jsonb_path_ops);
CREATE INDEX  ON geotools.lines   (fd);
CREATE INDEX  ON geotools.lines USING GIN (loc);
CREATE INDEX  ON geotools.lines USING gist (geom);
CREATE  INDEX  ON geotools.lines  (geom);
CREATE INDEX  ON geotools.lines   (sub);
CREATE INDEX  ON geotools.lines   (volt);
--******************************************************************************

DROP TABLE IF EXISTS geotools.roads;
CREATE TABLE geotools.roads (
    objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.line_seq'),
    rd_name text,
    loc text[],
    original_record jsonb,
    geom geometry(linestring,3857) UNIQUE
);
CREATE INDEX  ON geotools.roads USING GIN (original_record jsonb_ops);
CREATE INDEX  ON geotools.roads USING GIN (original_record jsonb_path_ops);
CREATE INDEX  ON geotools.roads (rd_name);
CREATE INDEX  ON geotools.roads USING GIN (loc);
CREATE INDEX  ON geotools.roads USING gist (geom);
--******************************************************************************
DROP TABLE IF EXISTS geotools.master_edge_table;
CREATE TABLE geotools.master_edge_table (
    objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.line_seq'),
    cl_id text,
    source bigint,
    target bigint,
    dist NUMERIC,
    cost NUMERIC,
    cost_mult NUMERIC,
    src_trgt_type TEXT,
    loc TEXT,
    rev TEXT,
    geom geometry(linestring,3857)
);
CREATE INDEX  ON geotools.master_edge_table (cl_id);
CREATE INDEX  ON geotools.master_edge_table (source);
CREATE INDEX  ON geotools.master_edge_table (target);

CREATE UNIQUE INDEX  ON geotools.master_edge_table (source,target,rev);

CREATE INDEX  ON geotools.master_edge_table (dist);
CREATE INDEX  ON geotools.master_edge_table (cost);
CREATE INDEX  ON geotools.master_edge_table (cost_mult);
CREATE INDEX  ON geotools.master_edge_table (src_trgt_type);
CREATE INDEX  ON geotools.master_edge_table (loc);
CREATE INDEX  ON geotools.master_edge_table (rev);
CREATE INDEX  ON geotools.master_edge_table using GIST (geom);

DROP TABLE IF EXISTS geotools.new_lines cascade;
CREATE TABLE geotools.new_lines (
    objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.line_seq'),
    source bigint,
    target bigint,
    cl_id text,
    dist numeric,
    cost numeric,
    v_level text,
    phase text,
    voltage text,
    conductor text,
    src_trgt_type TEXT,
    proj text,
    loc TEXT,
    rev TEXT,
    geom geometry(linestring,3857)
);

CREATE INDEX  ON geotools.new_lines(source);
CREATE INDEX  ON geotools.new_lines(target);
CREATE INDEX  ON geotools.new_lines(cl_id);
CREATE INDEX  ON geotools.new_lines(dist);
CREATE INDEX  ON geotools.new_lines(cost);
CREATE INDEX  ON geotools.new_lines(v_level);
CREATE INDEX  ON geotools.new_lines(phase);
CREATE INDEX  ON geotools.new_lines(voltage);
CREATE INDEX  ON geotools.new_lines(conductor);
CREATE INDEX  ON geotools.new_lines(src_trgt_type);
CREATE INDEX  ON geotools.new_lines(proj);
CREATE INDEX  ON geotools.new_lines(loc);
CREATE INDEX  ON geotools.new_lines(rev);
CREATE INDEX  ON geotools.new_lines using GIST (geom);




CREATE or REPLACE VIEW results_export.cl_boubaries AS
SELECT
  objectid,
  cl_id,
  b_cnt,
  hh_cnt,
  demand,
  dist,
  tr_size,
  v_level,
  phase,
  voltage,
  hull_geom geom
FROM
  geotools.bldgs_cl;

CREATE or REPLACE VIEW results_export.cl_centroid AS
SELECT
  objectid,
  cl_id,
  b_cnt,
  hh_cnt,
  demand,
  dist,
  tr_size,
  v_level,
  phase,
  voltage,
  ce_geom geom
FROM
  geotools.bldgs_cl;

CREATE or REPLACE VIEW results_export.lines AS
SELECT
  id,
  source,
  target,
  cl_id,
  cost,
  v_level,
  phase,
  voltage,
  conductor,
    geom geom
FROM geotools.edge_table;

--###############################################################################
DROP TABLE IF EXISTS geotools.demand_curve;
CREATE TABLE geotools.demand_curve (
    cust numeric NOT NULL,
    kwh numeric NOT NULL,
    demand numeric NOT NULL
);
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ALTER TABLE ONLY geotools.demand_curve
    ADD CONSTRAINT geotools_demand_curve_pk PRIMARY KEY (cust, kwh);
CREATE INDEX ON geotools.demand_curve (kwh);
CREATE INDEX ON geotools.demand_curve (cust);
CREATE INDEX ON geotools.demand_curve (demand);
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
TRUNCATE geotools.demand_curve ;
INSERT INTO geotools.demand_curve   (cust, kwh, demand)
    select cust, kwh, round((cust * (1 - 0.4 * cust + 0.4 * (cust ^ 2 + 40) ^ 0.5) * (0.0059256 * kwh^ 0.885))::NUMERIC, 1) demand
from (SELECT generate_series(1,1000) cust , kwh.* kwh FROM  generate_series(1,300) kwh) z;
--###############################################################################

DROP TABLE IF EXISTS config.equipment;
CREATE TABLE config.equipment (
  objectid BIGINT PRIMARY KEY DEFAULT nextval('geotools.global_seq'),
  lbl text UNIQUE,
  remark text,
  size text,
  u_cost NUMERIC
);


--###############################################################################
CREATE OR REPLACE FUNCTION geotools.get_cust_cnt(in_kwh numeric, in_demand NUMERIC) RETURNS INTEGER
    LANGUAGE sql
    AS $$
 select coalesce( (SELECT
   cust::INTEGER
  FROM geotools.demand_curve d WHERE d.kwh = in_kwh AND demand >= in_demand ORDER BY demand ASC limit 1),1000);
  $$;--SELECT * FROM geotools.demand_curve d WHERE d.kwh = 18 AND cust=1000 ORDER BY demand ASC limit 1
--#################################################################################
create or replace function geotools.clear_cl_id(in_loc text, in_rev text) returns void
LANGUAGE SQL
AS $$
update  geotools.bldgs b set cl_id = 'unk'/*, sts=CASE WHEN sts='clustered' THEN 'cluster' ELSE sts END*/
   where  loc=in_loc  and rev=in_rev and cl_id <>'unk';
$$;

-- Function: geotools.reset_sts_clustered(text, text)

-- DROP FUNCTION geotools.reset_sts_clustered(text, text);

CREATE OR REPLACE FUNCTION geotools.reset_sts_clustered(
    in_loc text,
    in_rev text)
  RETURNS void AS
$BODY$
   UPDATE geotools.bldgs b SET sts='cluster'
   where b.sts='clustered' and loc=in_loc and rev=in_rev;

$BODY$
  LANGUAGE sql VOLATILE
  COST 100;
ALTER FUNCTION geotools.reset_sts_clustered(text, text)
  OWNER TO postgres;


--#################################################################################
CREATE OR REPLACE FUNCTION geotools.reset_bldg_cl(in_loc text, in_rev text) RETURNS void
    LANGUAGE sql
    AS $$
   DELETE FROM geotools.bldgs_cl
   where  loc=in_loc   and rev=in_rev;

$$;
--#################################################################################
CREATE OR REPLACE  FUNCTION geotools.get_rev() RETURNS TEXT AS $$
   SELECT rev FROM geotools.revisions WHERE active;
$$ LANGUAGE sql;

--#################################################################################
CREATE or replace FUNCTION geotools.dbscan(in_dist numeric, in_bldg numeric, run_id text, in_loc text, in_rev text)
RETURNS BIGINT AS $$
WITH q1 AS (
    SELECT
      objectid,
      st_clusterdbscan(snap_geom, in_dist, (floor(in_bldg / hhr)) :: INTEGER)
      OVER () cl_id
    FROM geotools.bldgs
    WHERE sts = 'cluster'
          AND cl_id='unk'
          AND hhr >= 0.1
          AND loc = in_loc
          AND rev = in_rev
)
,q_update as(
  update  geotools.bldgs b set cl_id = loc||'-'||in_rev||'-'||run_id||'-'||x.cl_id
  from q1 x
  where x.objectid= b.objectid and x.cl_id is not null
  RETURNING x.cl_id
  )
SELECT count(*) FROM q_update
$$ LANGUAGE sql;
--#################################################################################

--#################################################################################
create or replace function geotools.kmean(in_dist numeric, min_hh_cnt numeric, max_hh_cnt numeric, in_tol numeric, in_loc text, in_rev text) returns void
LANGUAGE SQL
AS $$
WITH q1 AS (
        SELECT
          cl_id
          , sum(hhr)                   hh_cnt
          , (round(sum(hhr)/max_hh_cnt)) :: INTEGER k_hh_cnt
          , (floor(st_length(st_longestline(st_collect(snap_geom), st_centroid(st_collect(snap_geom)))) /
                in_dist )) :: INTEGER k_dist
        FROM geotools.bldgs
        WHERE  loc=in_loc  and rev=in_rev and cl_id <> 'unk'
        GROUP BY cl_id

    )
      , q2 AS (
        SELECT
          objectid,
          q1.cl_id || '-' || (st_clusterkmeans(snap_geom, greatest(k_dist,k_hh_cnt))
          OVER (
            PARTITION BY q1.cl_id )) cl_id
        FROM geotools.bldgs b
          JOIN q1 ON q1.cl_id = b.cl_id
        WHERE greatest(k_dist,k_hh_cnt) > 1 and b.loc=in_loc  and b.rev=in_rev
    )
    UPDATE geotools.bldgs b
    SET cl_id = q2.cl_id
    FROM q2
    WHERE q2.objectid = b.objectid and b.loc=in_loc  and b.rev=in_rev;
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    UPDATE geotools.bldgs b
    SET cl_id = 'unk'
    WHERE cl_id IN (SELECT cl_id
                    FROM geotools.bldgs b
                    WHERE  loc=in_loc  and rev=in_rev and cl_id <> 'unk'
                    GROUP BY cl_id
                    HAVING sum(hhr) < min_hh_cnt);
$$;

--#################################################################################
CREATE OR REPLACE FUNCTION geotools.kmeanrequired(in_dist NUMERIC,  max_hh_cnt numeric, in_tol numeric,  in_loc text, in_rev text)
  RETURNS NUMERIC
AS $$
WITH q1 AS (
    SELECT
      cl_id,
      sum(hhr)                                 hh_cnt,
      (round(sum(hhr)/max_hh_cnt)) :: INTEGER k_hh_cnt,
      (floor(st_length(
                st_longestline(st_collect(snap_geom), st_centroid(st_collect(snap_geom))
                )) / in_dist)) :: INTEGER k_dist
    FROM geotools.bldgs
    WHERE  loc=in_loc  and rev=in_rev and cl_id <> 'unk'
    GROUP BY cl_id
)
SELECT (count(cl_id)) :: NUMERIC
FROM q1
WHERE greatest(k_dist,k_hh_cnt) > 1
$$ LANGUAGE SQL;



--#################################################################################
CREATE OR REPLACE FUNCTION geotools.init_bldg_cl( in_tol NUMERIC,  in_loc text, in_rev text)
  RETURNS VOID AS $$
with q1 as ( --22s
  SELECT  cl_id, st_collect(snap_geom) col_geom
  FROM geotools.bldgs
  WHERE  loc=in_loc  and rev=in_rev and cl_id <> 'unk'
  GROUP BY cl_id
)
, q2 as (
      SELECT
        q1.cl_id,
        row_number()
          over(PARTITION BY q1.cl_id
                ORDER BY st_distance(st_centroid (col_geom),b.snap_geom) ASC, b.objectid ASC
            ) rnk,
        b.snap_geom ce_geom,
        b.objectid objectid
      FROM q1
      JOIN geotools.bldgs b on q1.cl_id=b.cl_id and b.loc=in_loc  and b.rev=in_rev

)
,q3 AS (
      SELECT
        cl_id,
        objectid,
        ce_geom
      FROM q2
      WHERE rnk=1
)
insert into geotools.bldgs_cl (objectid, cl_id, loc,  rev, ce_geom)
  select objectid, cl_id, in_loc,  in_rev, ce_geom from q3;
$$ LANGUAGE SQL;

--#####################################################################


--#####################################################################

CREATE OR REPLACE FUNCTION geotools.Voronoi_bldg_cl ( in_dist numeric, in_loc text, in_rev text)
  RETURNS VOID AS $$
with q1 as (
  select
    st_dump(ST_VoronoiPolygons (st_collect(ce_geom))) v
  from geotools.bldgs_cl
  WHERE  loc=in_loc  and rev=in_rev
)
,q2 as (
  select
    (v).path[1] vid
  ,(v).geom v_geom
  from q1

)
, q3 as(
  select
     cl_id
    ,ce_geom
    , st_buffer(ce_geom,in_dist) buff_geom
  from geotools.bldgs_cl
  where loc=in_loc and rev=in_rev
)
, q4 as(
  select cl_id, st_intersection(buff_geom,v_geom) geom from q3 cl
  join q2 v on ST_Intersects(cl.ce_geom,v.v_geom)
)
update geotools.bldgs_cl cl
set ver_geom= q4.geom
FROM q4
where q4.cl_id=cl.cl_id;
$$ LANGUAGE SQL;

--#####################################################################
CREATE OR REPLACE FUNCTION geotools.greedy_update_bldg_cl(in_loc TEXT, in_rev TEXT)
  RETURNS VOID AS $$
UPDATE geotools.bldgs b
SET cl_id = x.cl_id
FROM (
       SELECT
         cl.cl_id,
         b.objectid
       FROM geotools.bldgs_cl cl
         JOIN geotools.bldgs b ON st_intersects(b.snap_geom, cl.ver_geom)
       WHERE
        b.loc = in_loc AND b.rev = in_rev AND cl.loc = in_loc AND cl.rev = in_rev and  b.sts IN ('cluster', 'clustered')
     ) x
WHERE x.objectid = b.objectid;
$$ LANGUAGE SQL;
--#####################################################################
--#####################################################################

CREATE OR REPLACE FUNCTION geotools.update_adj_cnt(in_dist numeric, in_loc TEXT, in_rev TEXT)
  RETURNS VOID AS $$
UPDATE geotools.bldgs b
SET adj_cnt = x.adj_cnt , adj_cnt_dist=in_dist
FROM (
        select
        b1.objectid,
        sum(b2.hhr) adj_cnt
        from geotools.bldgs b1
        LEFT JOIN geotools.bldgs b2 on st_dwithin(b2.snap_geom,b1.snap_geom,in_dist)
        WHERE b1.loc=in_loc and b2.loc=in_loc
        AND b1.rev=in_rev and b2.rev=in_rev
        AND b1.sts in ('cluster','clustered') AND b2.sts in ('cluster','clustered')
       GROUP BY  b1.objectid
     ) x
WHERE x.objectid = b.objectid;
$$ LANGUAGE SQL;
--#####################################################################
CREATE OR REPLACE FUNCTION geotools.update_adj_cnt_rnd(in_dist numeric, in_loc TEXT, in_rev TEXT)
  RETURNS VOID AS $$
UPDATE geotools.bldgs b
SET adj_cnt = x.adj_cnt , adj_cnt_dist=in_dist
FROM (

       with qr1 AS (
         select * from geotools.bldgs b WHERE b.loc=in_loc and b.rev=in_rev AND
           b.sts in ('cluster','clustered')
         )
         select
         b1.objectid,
        sum(b2.hhr) adj_cnt
        from qr1 b1 LEFT JOIN qr1 b2 on st_dwithin(b2.snap_geom,b1.snap_geom,in_dist)
         GROUP BY  b1.objectid

     ) x
WHERE x.objectid = b.objectid;
$$ LANGUAGE SQL;
--#####################################################################

CREATE OR REPLACE FUNCTION geotools.dense_update_bldg_cl(min_hh numeric,in_loc TEXT, in_rev TEXT)
  RETURNS VOID AS $$
UPDATE geotools.bldgs b
SET cl_id = x.cl_id
FROM (
       SELECT
         cl.cl_id,
         b.objectid
       FROM geotools.bldgs_cl cl
         JOIN geotools.bldgs b ON st_intersects(b.snap_geom, cl.ver_geom)
       WHERE
          b.loc = in_loc          AND b.rev = in_rev
         AND cl.loc = in_loc         AND cl.rev = in_rev
            and b.sts IN ('cluster', 'clustered')
         AND b.adj_cnt>=min_hh
     ) x
WHERE x.objectid = b.objectid;
$$ LANGUAGE SQL;
--#####################################################################

CREATE OR REPLACE FUNCTION geotools.update_bldg_cl_centroid(in_tol NUMERIC,in_loc TEXT, in_rev TEXT)
  RETURNS INTEGER AS
$$
DECLARE
  u_ce INTEGER :=0;

BEGIN
  WITH q1 AS ( --22s
      SELECT
        cl_id,
        st_collect(snap_geom) col_geom
      FROM geotools.bldgs
      WHERE  loc = in_loc AND rev = in_rev and cl_id <> 'unk'
      GROUP BY cl_id
  )
    , q2 AS (
      SELECT
        q1.cl_id,
        row_number()
          over(PARTITION BY q1.cl_id
                ORDER BY st_centroid (col_geom)<->b.snap_geom ASC
            ) rnk,
        b.snap_geom ce_geom,
        b.objectid objectid
      FROM q1
      JOIN geotools.bldgs b on q1.cl_id=b.cl_id
  )
    , q3 AS (
      SELECT
        cl_id,
        objectid,
        ce_geom
      FROM q2
      WHERE rnk=1
  )
  , q_update as(
  UPDATE geotools.bldgs_cl cl
  SET objectid = x.objectid, ce_geom = x.ce_geom
  FROM q3 x
  WHERE cl.cl_id = x.cl_id AND NOT st_equals(x.ce_geom, cl.ce_geom)
  RETURNING 1)
    select count(*) into u_ce from q_update;
  RETURN u_ce;
END;

$$ LANGUAGE 'plpgsql';

--##############################################################################################
CREATE OR REPLACE FUNCTION geotools.update_bldg_cl_fields(in_grid_size NUMERIC, in_kwh_month NUMERIC, in_loc TEXT, in_rev TEXT)
  RETURNS VOID AS
$$
/*DECLARE  u_ce INTEGER :=0;*/
BEGIN
with q1 as ( --22s
    SELECT
      b.cl_id,
      count(b.objectid)  b_cnt,
      sum(b.hhr)         hh_cnt,
      st_collect(b.snap_geom) col_geom,
      st_collect(st_expand(b.snap_geom,in_grid_size/2)) col_geom_expanded
    FROM geotools.bldgs b
    WHERE   loc = in_loc   AND rev = in_rev and cl_id <> 'unk'
    GROUP BY cl_id
)
, q2 as (
    SELECT
      cl.objectid,
      cl.cl_id,
      ce.loc_list,
      ce.loc,
      b.b_cnt,
      round(b.hh_cnt)                         hh_cnt,
      b.col_geom                              col_geom,
      cl.ce_geom                              ce_geom,
      st_concavehull(col_geom_expanded, 0.99) hull_geom
    FROM q1 b
      JOIN geotools.bldgs_cl cl ON cl.cl_id = b.cl_id
      JOIN geotools.bldgs ce ON ce.objectid = cl.objectid
    WHERE cl.rev = in_rev  AND cl.loc = in_loc
)
,q3 AS (
    SELECT
      objectid,
      cl_id,
      loc,
      loc_list,
      b_cnt,
      hh_cnt,
      round(hh_cnt * (1 - 0.4 * hh_cnt + 0.4 * (hh_cnt ^ 2 + 40) ^ 0.5) * (0.0059256 * in_kwh_month ^ 0.885), 1) demand,
      round(st_maxdistance(ce_geom, hull_geom))                                                      dist,
       hull_geom
    FROM q2
)
UPDATE geotools.bldgs_cl cl set (loc,loc_list,b_cnt,hh_cnt,demand,dist,hull_geom)=
       (select loc,loc_list,b_cnt,hh_cnt,demand,dist,hull_geom FROM q3
       WHERE q3.objectid=cl.objectid)
  WHERE cl.rev = in_rev  AND (cl.loc = in_loc or cl.loc is null);
  END;
$$ LANGUAGE 'plpgsql';
--####################################################################################################################

CREATE OR REPLACE FUNCTION geotools.clear_clid_outside_buffer( in_dist numeric, in_tol NUMERIC,  in_loc text, in_rev text)
  RETURNS BIGINT AS $$

WITH q1 AS (
    SELECT
      cl_id,
      st_centroid(st_collect(snap_geom)) ce_geom
    FROM geotools.bldgs
    WHERE  loc = in_loc AND rev = in_rev and cl_id <>'unk'
    GROUP BY cl_id
)
  , q2 AS (
    SELECT
      b.objectid  objectid,
      cl.cl_id,
      st_distance(cl.ce_geom, b.snap_geom)  dist
    FROM q1 cl
      JOIN geotools.bldgs b ON cl.cl_id = b.cl_id AND b.loc = in_loc AND b.rev = in_rev
)
  , q_update AS (
    UPDATE geotools.bldgs b SET cl_id='unk'
    FROM q2
    WHERE q2.objectid=b.objectid and q2.dist>in_dist
    RETURNING 1
)
SELECT count(*)
FROM q_update;
$$ LANGUAGE SQL;

--#####################################################################
--***********************************************************************************


CREATE OR REPLACE FUNCTION geotools.explode_linestring(in_line GEOMETRY('LINESTRING'))
  RETURNS SETOF GEOMETRY('LINESTRING') AS
$$
BEGIN

  RETURN QUERY
  SELECT st_makeline(geom1, geom2)
  FROM
    (SELECT
       p.geom  geom2,
       lag(p.geom)
       OVER () geom1
     FROM st_dumppoints(in_line) p) l
  WHERE geom1 IS NOT NULL AND geom2 IS NOT NULL;
END;
$$ LANGUAGE 'plpgsql';
--#####################################################################################
CREATE OR REPLACE FUNCTION geotools.del_rds_by_len( in_len NUMERIC, in_loc TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt BIGINT :=0;
BEGIN

  WITH qd as(
    DELETE FROM geotools.roads rd
  WHERE rd.loc @> ARRAY [in_loc] and st_length(geom)<=in_len
    RETURNING 1)
  SELECT count(*) INTO rt from qd;

RETURN rt;
END
$$ LANGUAGE 'plpgsql';

--#####################################################################################
--select geotools.del_ovelaped_rds( 'MASAKT')
CREATE OR REPLACE FUNCTION geotools.del_overlaped_rds( in_loc TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val1 BIGINT :=0;
  rt_val2 BIGINT :=0;
BEGIN
  WITH q10 AS (
      SELECT
        objectid,
        ROW_NUMBER()
        OVER (
          PARTITION BY geom ) rnk
      FROM geotools.roads
  )
    , del_querry AS
  (
      delete FROM geotools.roads rd
    WHERE objectid IN ( SELECT q10.objectid FROM q10 WHERE rnk>1)
    RETURNING 1
  )
      SELECT count(*)
      INTO rt_val2
      FROM del_querry;

  WITH qd as(
    DELETE FROM geotools.roads rd
  WHERE  rd.loc @> ARRAY [in_loc] and objectid IN (
    SELECT o1
    FROM (
           SELECT
             rd1.objectid              o1,
             rd2.objectid              o2,
             row_number()
             OVER (
               PARTITION BY case when rd1.geom< rd2.geom then rd1.objectid||'-'||rd2.objectid else rd2.objectid||'-'||rd1.objectid end ) rnk
           FROM geotools.roads rd1
             JOIN geotools.roads rd2 ON rd1.geom && rd2.geom and st_within(rd1.geom , st_buffer(rd2.geom ,2)) AND rd1.objectid <> rd2.objectid) rd
    WHERE rd.rnk > 1)
    RETURNING 1)
  SELECT count(*) INTO rt_val1 from qd;



RETURN rt_val2+rt_val1;
END
$$ LANGUAGE 'plpgsql';
--88888888888888888888888888888888888888888888888888888888888888888888888888888

CREATE OR REPLACE FUNCTION geotools.del_overlaped_rds_2( in_loc TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
  with q10 as (
  SELECT r2.objectid FROM geotools.roads r1
  JOIN geotools.roads r2 on r1.objectid<>r2.objectid and  st_contains(r1.geom,r2.geom)
    where r1.loc @> ARRAY [in_loc] and r2.loc @> ARRAY [in_loc]
    )
  ,q_delete as(
    delete from geotools.roads WHERE objectid in (select objectid from q10)

    )
  select count(*) into rt_val from q10;
  return rt_val;
END
$$ LANGUAGE 'plpgsql';
-- DROP TYPE geotools.line_snap_info;

CREATE TYPE geotools.line_snap_info AS
   (objectid bigint,
    pos text,
    snap_objectid bigint);
--#####################################################################################
CREATE OR REPLACE FUNCTION geotools.snap_rds(in_dist NUMERIC, in_loc TEXT)
  RETURNS BIGINT AS
$$
  Declare
    in_objectid geotools.line_snap_info[];
    t_objectid geotools.line_snap_info;
    t_geom GEOMETRY;
    t_point geometry;
      rt BIGINT :=0;
  begin

WITH q1 AS (
    SELECT DISTINCT rd.objectid
    FROM geotools.roads rd
      JOIN geotools.roads rd1 ON rd1.geom&& st_expand(st_startpoint(rd.geom),in_dist) and
                                st_intersects(rd1.geom, st_startpoint(rd.geom))
    WHERE rd.objectid <> rd1.objectid
          AND rd.loc @> ARRAY[in_loc] AND rd1.loc @> ARRAY[in_loc]
)
  , q2 AS (
    SELECT
      rd.objectid,
      'start'::TEXT pos,
      rd1.objectid objectid1,
      row_number() OVER (PARTITION BY rd.objectid) rnk,
      rd.geom,
      rd1.geom     geom1
    FROM geotools.roads rd
      JOIN geotools.roads rd1 ON st_dwithin(rd1.geom, st_startpoint(rd.geom), in_dist)
    WHERE rd.objectid <> rd1.objectid
          AND rd.objectid NOT IN (SELECT *
                                  FROM q1)
          AND rd.loc @> ARRAY[in_loc] AND rd1.loc @> ARRAY[in_loc]
)
  , q3 AS (
    SELECT DISTINCT
      rd.objectid
    FROM geotools.roads rd
      JOIN geotools.roads rd1 ON rd1.geom && st_expand(st_endpoint(rd.geom),in_dist)  and
                                st_intersects(rd1.geom, st_endpoint(rd.geom))
    WHERE rd.objectid <> rd1.objectid
          AND rd.loc @> ARRAY[in_loc] AND rd1.loc @> ARRAY[in_loc]
)
  , q4 AS (
    SELECT
      rd.objectid,
      'end'::TEXT pos,
      rd1.objectid objectid1,
      row_number() OVER (PARTITION BY rd.objectid) rnk,
      rd.geom,
      rd1.geom     geom1
    FROM geotools.roads rd
      JOIN geotools.roads rd1 ON st_dwithin(rd1.geom, st_endpoint(rd.geom), in_dist)
    WHERE rd.objectid <> rd1.objectid
          AND rd.objectid NOT IN (SELECT *
                                  FROM q3)
          AND rd.loc @> ARRAY[in_loc] AND rd1.loc @> ARRAY[in_loc]
)
  , q5 AS (
  SELECT *
  FROM q2
  UNION
  SELECT *
  FROM q4)
SELECT ARRAY_agg(ROW (objectid, pos::TEXT, objectid1)) into in_objectid
FROM q5 where rnk=1;

rt:=array_length(in_objectid,1);

IF in_objectid is null THEN
  RETURN 0;
END IF;
RAISE NOTICE '% pairs of lines will be snapped: %',rt, in_objectid ;


FOREACH t_objectid in ARRAY in_objectid loop

  with q10 as (
      SELECT (st_dumppoints(geom)).geom geom
    FROM geotools.roads rd2
         WHERE rd2.objectid = t_objectid.snap_objectid)
select st_collect(geom) into t_geom from q10;

  select case WHEN t_objectid.pos='start' THEN st_closestpoint(t_geom,st_startpoint( rd1.geom))
     ELSE st_closestpoint(t_geom,st_endpoint(rd1.geom)) end INTO t_point
  FROM  geotools.roads rd1
   WHERE rd1.objectid=t_objectid.objectid;

--   raise notice '% tpoint for %', t_point, t_objectid;
--   BEGIN
--     UPDATE  geotools.roads rd2 SET geom= st_snap(geom,t_point,0.1)
--     WHERE rd2.objectid=t_objectid.snap_objectid;
--     --RETURN ;
--     exception when others then
--       raise notice '% was rolled back', t_objectid;
--   END ;
SELECT    case WHEN t_objectid.pos='start' THEN st_setpoint(rd1.geom,0,t_point)
     ELSE st_setpoint(rd1.geom,st_npoints(rd1.geom)-1,t_point) end INTO t_geom
from geotools.roads rd1
   WHERE rd1.objectid=t_objectid.objectid;

  if not st_equals(st_startpoint(t_geom),st_endpoint(t_geom)) THEN
   BEGIN
   UPDATE geotools.roads rd1 SET geom=t_geom
   WHERE rd1.objectid=t_objectid.objectid;
--     returning geom into t_geom;
--     raise notice '%', t_geom;
    exception when others then
      raise notice '% was rolled back', t_objectid;
    END ;
  END IF;

END LOOP;
RETURN rt;
    END
$$LANGUAGE 'plpgsql' ;



--#####################################################################################

CREATE OR REPLACE FUNCTION geotools.node_rd(in_loc TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  in_rd geotools.ROADS [];
BEGIN

  WITH q1 AS (
      SELECT
        rd1.objectid,
        rd1.rd_name,
        rd1.loc,
        rd1.original_record,
        st_dump(st_split(rd1.geom, st_collect(rd2.geom))) dmp
      FROM geotools.roads rd1
        JOIN geotools.roads rd2 ON ST_intersects(rd2.geom, rd1.geom)
      WHERE rd1.objectid <> rd2.objectid
            AND rd1.loc @> ARRAY [in_loc] AND rd1.loc @> ARRAY [in_loc]
      GROUP BY rd1.objectid
  )
    , q2 AS (
      SELECT
        CASE WHEN (dmp).path [1] = 1
          THEN objectid
        ELSE -1 * objectid END  objectid,
        rd1.rd_name,
        rd1.loc,
        rd1.original_record,
        (dmp).geom geom
      FROM q1 rd1
  )
  SELECT array_agg(ROW (q2.*))
  INTO in_rd
  FROM q2;

  DELETE FROM geotools.roads
  WHERE objectid IN (SELECT objectid
                     FROM unnest(in_rd) rd
                     WHERE rd.objectid > 0);

  INSERT INTO geotools.roads (rd_name, loc, original_record, geom)
    (SELECT
       rd_name,
       loc,
       original_record,
       geom
     FROM unnest(in_rd) rd)
  on CONFLICT (geom) DO NOTHING ;

  RETURN array_length(in_rd, 1);
END
$$ LANGUAGE 'plpgsql';
--***********************************************************************************
CREATE OR REPLACE FUNCTION geotools.split_rd_by_line(in_loc TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  in_rd geotools.ROADS [];
BEGIN
  WITH q1 AS (
      SELECT
        rd1.objectid,
        rd1.rd_name,
        rd1.loc,
        rd1.original_record,
        st_dump(st_split(rd1.geom, st_collect(l.geom))) dmp
      FROM geotools.roads rd1
        JOIN geotools.lines l ON ST_Crosses(l.geom, rd1.geom)
      WHERE rd1.loc @> ARRAY [in_loc]
      GROUP BY rd1.objectid
  )
    , q2 AS (
      SELECT
        CASE WHEN (dmp).path [1] = 1
          THEN objectid
        ELSE -1 * objectid END  objectid,
        rd1.rd_name,
        rd1.loc,
        rd1.original_record,
        (dmp).geom geom
      FROM q1 rd1
  )
  SELECT array_agg(ROW (q2.*))
  INTO in_rd
  FROM q2;

  DELETE FROM geotools.roads
  WHERE objectid IN (SELECT objectid
                     FROM unnest(in_rd) rd
                     WHERE rd.objectid > 0);

  INSERT INTO geotools.roads (rd_name, loc, original_record, geom)
    (SELECT
       rd_name,
       loc,
       original_record,
       geom
     FROM unnest(in_rd) rd)
     on CONFLICT (geom) DO NOTHING ;

  RETURN array_length(in_rd, 1);
END
$$ LANGUAGE 'plpgsql';
--***********************************************************************************
CREATE OR REPLACE FUNCTION geotools.segment_rd(seg_len NUMERIC, in_loc TEXT )
  RETURNS BIGINT AS
$$
DECLARE
  in_rd geotools.ROADS [];
BEGIN
  WITH q10 AS (
      SELECT
        objectid,
        rd_name,
        loc,
        original_record,

        geotools.explode_linestring( st_segmentize( geom, seg_len)) geom
      FROM geotools.roads rd1
      WHERE rd1.loc @> ARRAY [in_loc] AND rd1.loc @> ARRAY [in_loc]
      GROUP BY rd1.objectid
  )

  SELECT array_agg(ROW (rd.*))
  INTO in_rd
  FROM q10 rd;

  DELETE FROM geotools.roads WHERE loc @> ARRAY [in_loc];

  INSERT INTO geotools.roads (rd_name, loc, original_record, geom)
    (SELECT
       rd_name,
       loc,
       original_record,
       geom
     FROM unnest(in_rd) rd)
       on CONFLICT (geom) DO NOTHING ;

  RETURN array_length(in_rd, 1);
END
$$ LANGUAGE 'plpgsql';

--***********************************************************************************
CREATE OR REPLACE FUNCTION geotools.explode_rds(in_loc text)
  RETURNS bigint AS
$$
DECLARE
  rt BIGINT :=0;
  in_rd_ar geotools.roads[];
BEGIN
    SELECT
      array_agg(rd.*) INTO in_rd_ar
    FROM geotools.roads rd
    WHERE rd.loc @> ARRAY[in_loc] and st_npoints(rd.geom)>2;

  DELETE FROM geotools.roads WHERE  objectid in
    (SELECT rd1.objectid FROM unnest(in_rd_ar) rd1);

  WITH qi as(
  INSERT INTO geotools.roads (rd_name, loc, original_record, geom)
    (SELECT  rd_name, loc, original_record, geotools.explode_linestring(geom) geom FROM unnest(in_rd_ar) rd1)
  RETURNING 1
  )
  SELECT count(*) into rt
  FROM qi;
RETURN rt;

END;
$$ LANGUAGE 'plpgsql';



--***********************************************************************************
CREATE OR REPLACE FUNCTION geotools.explode_lines(in_loc text)
  RETURNS bigint AS
$$
DECLARE
  rt BIGINT :=0;
  in_rd_ar geotools.roads[];
BEGIN
    SELECT
      array_agg(rd.*) INTO in_rd_ar
    FROM geotools.lines rd
    WHERE rd.loc @> ARRAY[in_loc] and st_npoints(rd.geom)>2;

  DELETE FROM geotools.roads WHERE  objectid in
    (SELECT rd1.objectid FROM unnest(in_rd_ar) rd1);

  WITH qi as(
  INSERT INTO geotools.roads (rd_name, loc, original_record, geom)
    (SELECT  rd_name, loc, original_record, geotools.explode_linestring(geom) geom FROM unnest(in_rd_ar) rd1)
  RETURNING 1
  )
  SELECT count(*) into rt
  FROM qi;
RETURN rt;

END;
$$ LANGUAGE 'plpgsql';

--#################################################################################################################


CREATE OR REPLACE FUNCTION geotools.init_nodes( in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
 DELETE  FROM geotools.nodes where  loc = in_loc AND rev = in_rev;

  WITH q10 AS (  --3
      SELECT
        sum(hhr)        hh_cnt,
        count(objectid) b_cnt,
        min(cl_id)      cl_id,
        min(snap_geom)  geom
      FROM geotools.bldgs b
      WHERE  b.loc = in_loc AND b.rev = in_rev and b.cl_id <> 'unk' AND hhr >= 0.1
      GROUP BY snap_geom
  )
    , q20 AS (
      SELECT
        n.hh_cnt,
        n.b_cnt,
        n.cl_id,
        CASE WHEN cl.objectid IS NULL
          THEN 'pole'
        ELSE 'tr_pole' END                ntype,
        n.geom
      FROM q10 n
        LEFT JOIN geotools.bldgs_cl cl
          ON st_dwithin(cl.ce_geom, n.geom :: GEOMETRY, 1) AND cl.loc = in_loc AND cl.rev = in_rev
  )
    , q_insert as(
  INSERT INTO geotools.nodes ( loc, rev, hh_cnt, b_cnt, cl_id, node_type, geom)
    (SELECT       in_loc,       in_rev,       hh_cnt,       b_cnt,       cl_id,       ntype,       geom     FROM q20)
  RETURNING 1)
  SELECT count(*) into rt_val from q_insert;
  RETURN rt_val;
 END;

$$ LANGUAGE 'plpgsql';

--#############################
CREATE OR REPLACE FUNCTION geotools.insert_pole_to_tr_edges(in_loc TEXT, in_rev TEXT, cost_pow NUMERIC DEFAULT 4)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
  DELETE FROM geotools.master_edge_table met
  WHERE met.loc = in_loc AND met.rev = in_rev AND met.src_trgt_type = 'pole_to_tr';

  WITH q10 AS (
      SELECT
        tr.cl_id,
        tr.objectid                      source,
        p.objectid                       target,
        st_distance(tr.geom, p.geom)     dist,
        st_distance(tr.geom, p.geom) ^ cost_pow "cost",
        1                                cost_mult,
        'pole_to_tr'                     src_trgt_type,
        tr.loc                           loc,
        tr.rev,
        row_number() OVER (partition by tr.cl_id ORDER BY st_distance(tr.geom,p.geom)) rnk,
        st_makeline(tr.geom, p.geom)     geom
      FROM geotools.nodes p
        JOIN geotools.nodes tr ON tr.cl_id = p.cl_id
      WHERE p.node_type = 'pole' AND tr.node_type = 'tr_pole'
            AND p.loc = in_loc AND p.rev = in_rev
            AND tr.loc = in_loc AND tr.rev = in_rev
            --AND p.cl_id = ''
  )
    , q_insert AS (
    INSERT INTO geotools.master_edge_table
    (cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom)
      SELECT cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom
      FROM q10
      WHERE rnk<=4
    RETURNING 1 cnt
  )
  SELECT count(cnt)
  INTO rt_val
  FROM q_insert;

  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';
--#############################################################################

--#############################
CREATE OR REPLACE FUNCTION geotools.insert_tr_to_rd_in_cl_edges(in_loc TEXT, in_rev TEXT,cost_pow NUMERIC DEFAULT 4)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
  DELETE FROM geotools.master_edge_table met
  WHERE met.loc = in_loc AND met.rev = in_rev AND met.src_trgt_type = 'tr_to_rd';

  WITH q10 AS (
      SELECT
        tr.cl_id,
        tr.objectid                      source,
        p.objectid                       target,
        st_distance(tr.geom, p.geom)     dist,
        st_distance(tr.geom, p.geom) ^ cost_pow "cost",
        1                                cost_mult,
        'tr_to_rd'                     src_trgt_type,
        tr.loc                           loc,
        tr.rev,
        row_number() OVER (PARTITION BY tr.cl_id ORDER BY st_distance(tr.geom,p.geom)) rnk,
        st_makeline(tr.geom, p.geom)     geom
      FROM geotools.nodes p
        JOIN geotools.nodes tr ON tr.cl_id = p.cl_id
      WHERE p.node_type in( 'rd' , 'rd_line') AND tr.node_type = 'tr_pole'
            AND p.loc = in_loc AND p.rev = in_rev
            AND tr.loc = in_loc AND tr.rev = in_rev
           -- AND p.cl_id = ''
  )
    , q_insert AS (
    INSERT INTO geotools.master_edge_table
    (cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom)
      SELECT cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom
      FROM q10
      WHERE rnk=1
    RETURNING 1 cnt
  )
  SELECT count(cnt)
  INTO rt_val
  FROM q_insert;

  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';
--#############################################################################
CREATE OR REPLACE FUNCTION geotools.insert_pole_to_pole_edges(in_loc TEXT, in_rev TEXT, cost_pow NUMERIC DEFAULT 4)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
  DELETE FROM geotools.master_edge_table met
  WHERE met.loc = in_loc AND met.rev = in_rev AND met.src_trgt_type = 'pole_to_pole';

  WITH q10 AS (
      SELECT DISTINCT
        p1.cl_id,
        least(p1.objectid, p2.objectid )                     source,
        greatest(p1.objectid, p2.objectid )                         target,
        case when p1.objectid < p2.objectid then st_makeline(p1.geom, p2.geom) else st_makeline(p2.geom, p1.geom) END   geom
      FROM geotools.nodes p1
        JOIN geotools.nodes p2 ON p2.cl_id = p1.cl_id and p2.node_type = 'pole'  and p1.objectid<>p2.objectid
      WHERE p1.node_type = 'pole'
            AND p1.loc = in_loc AND p1.rev = in_rev
            AND p2.loc = in_loc AND p2.rev = in_rev
           -- AND p1.cl_id = ''
  )
      , q30 as (
       SELECT
        cl_id,
        source,
        target,
        st_length(geom) dist,
        st_length(geom) ^ cost_pow "cost",
        1                                cost_mult,
        'pole_to_pole'                     src_trgt_type,
        row_number() OVER (PARTITION BY source  ORDER BY st_length (geom) ASC ) rnk,
        geom
      FROM q10 l
    )
    , q_insert AS (
    INSERT INTO geotools.master_edge_table
    (cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom)
      SELECT cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, in_loc, in_rev, geom
      FROM q30
      WHERE rnk<=4 ON CONFLICT DO NOTHING
    RETURNING 1 cnt
  )
  SELECT count(cnt)
  INTO rt_val
  FROM q_insert;

  with q10 AS (
  SELECT DISTINCT l1.objectid
  from geotools.master_edge_table l1
  JOIN geotools.master_edge_table l2 on st_contains(l1.geom,l2.geom) and l1.objectid<>l2.objectid
  WHERE l1.rev=in_rev and l1.loc=in_loc
    and l2.rev=in_rev and l2.loc=in_loc
    and l1.src_trgt_type = 'pole_to_pole'   and l2.src_trgt_type = 'pole_to_pole'
  )
  ,q_delete as(
  DELETE FROM geotools.master_edge_table l
  where l.objectid in (SELECT l1.objectid from q10 l1)
  returning 1)
  SELECT rt_val-count(*) into rt_val from q_delete;

    RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';



--#############################################################################
CREATE OR REPLACE FUNCTION geotools.insert_pole_to_rd_edges(in_loc TEXT, in_rev TEXT, cost_pow NUMERIC DEFAULT 4)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
  DELETE FROM geotools.master_edge_table met
  WHERE met.loc = in_loc AND met.rev = in_rev AND met.src_trgt_type = 'pole_to_rd';

  WITH q10 AS (
      SELECT
        tr.cl_id,
        p1.objectid                      source,
        p2.objectid                      target,
        st_distance(p1.geom,p2.geom)     dist,
        st_distance(p1.geom,p2.geom)^ cost_pow "cost",
        1                                cost_mult,
        'pole_to_rd'                     src_trgt_type,
        tr.loc                           loc,
        tr.rev,
        row_number() OVER (PARTITION BY p1.objectid  ORDER BY st_distance(p1.geom,p2.geom)) rnk,
        st_makeline(p1.geom, p2.geom)     geom
      FROM geotools.nodes p1
        JOIN geotools.nodes tr ON tr.cl_id = p1.cl_id AND tr.node_type = 'tr_pole'
        JOIN geotools.nodes p2 ON p2.cl_id = p1.cl_id and p2.node_type in( 'rd' , 'rd_line')
      WHERE p1.node_type = 'pole'
            AND st_distance(p1.geom,p2.geom)<st_distance(p1.geom,tr.geom)
            AND p1.loc = in_loc AND p1.rev = in_rev
            AND p2.loc = in_loc AND p2.rev = in_rev
            AND tr.loc = in_loc AND tr.rev = in_rev
           -- AND p1.cl_id = ''
  )
    , q_insert AS (
    INSERT INTO geotools.master_edge_table
    (cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom)
      SELECT cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom
      FROM q10
      WHERE rnk=1 ON CONFLICT DO NOTHING
    RETURNING 1 cnt
  )
  SELECT count(cnt)
  INTO rt_val
  FROM q_insert;

  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';
--#############################
CREATE OR REPLACE FUNCTION geotools.insert_rd_to_rd_nodes(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN

    DELETE FROM geotools.nodes n
  WHERE n.loc = in_loc AND n.rev = in_rev AND n.node_type in( 'rd' , 'rd_line') ;

  with q10 as(
    SELECT  rd.geom
    FROM geotools.roads rd
    WHERE rd.loc @> ARRAY[in_loc]
  )
  , q20 as(
      SELECT DISTINCT (st_dumppoints(geom)).geom from q10
        )
  , q30 as(
    select  nextval('geotools.pt_seq') objectid, geom from q20
      )
  , q_node_insert as(
    INSERT INTO geotools.nodes (objectid,loc,rev,hh_cnt,b_cnt,node_type,geom)
     select objectid,in_loc,in_rev,0,0,  'rd', geom from q30 on CONFLICT do NOTHING
    RETURNING 1
   )
   select count(*) into rt_val from q_node_insert;


  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';

--#############################
CREATE OR REPLACE FUNCTION geotools.update_rd_nodes_cl(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN

  with q10 as(
SELECT
    n.objectid,
    cl.cl_id
  FROM geotools.nodes n
    JOIN geotools.bldgs_cl cl on st_dwithin(n.geom,cl.hull_geom,25)
    WHERE n.rev=in_rev and n.loc=in_loc
    AND cl.rev=in_rev and cl.loc=in_loc
  )
  , q_node_update as(
    UPDATE geotools.nodes n SET cl_id= q10.cl_id
    FROM q10
    WHERE n.objectid = q10.objectid
    RETURNING 1
   )
   select count(*) into rt_val from q_node_update;


  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';

--#############################
CREATE OR REPLACE FUNCTION geotools.update_new_lines_cl(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN

  with q10 as(
SELECT
    l.objectid,
    cl.cl_id
  FROM geotools.new_lines l
    JOIN geotools.bldgs_cl cl on st_intersects(l.geom,cl.hull_geom)
    WHERE l.rev=in_rev and l.loc=in_loc
    AND cl.rev=in_rev and cl.loc=in_loc
  )
  , q_node_update as(
    UPDATE geotools.nodes n SET cl_id= q10.cl_id
    FROM q10
    WHERE n.objectid = q10.objectid
    RETURNING 1
   )
   select count(*) into rt_val from q_node_update;


  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';

--#############################
CREATE OR REPLACE FUNCTION geotools.update_rd_nodes_line(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN

  with q10 as(
SELECT
    n.objectid
  FROM geotools.nodes n
    JOIN geotools.lines l on st_dwithin(n.geom,l.geom,0.1)
    WHERE n.rev=in_rev and n.loc=in_loc
  )
  , q_node_update as(
    UPDATE geotools.nodes n SET node_type= 'rd_line'
    FROM q10
    WHERE n.objectid = q10.objectid
    RETURNING 1
   )
   select count(*) into rt_val from q_node_update;


  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';

--#############################
CREATE OR REPLACE FUNCTION geotools.insert_rd_to_rd_edges(in_loc TEXT, in_rev TEXT, cost_pow NUMERIC DEFAULT 1)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
  DELETE FROM geotools.master_edge_table met
  WHERE met.loc = in_loc AND met.rev = in_rev AND met.src_trgt_type = 'rd_to_rd';

     with  q40 AS (
      SELECT
        coalesce(s.cl_id,e.cl_id)  cl_id,
        s.objectid source,
        e.objectid target,
        round(st_length(l.geom)) dist,
        round(st_length(l.geom))^cost_pow "cost",
        1 cost_mult,
        'rd_to_rd' src_trgt_type,
        in_loc loc,
        in_rev rev,
        l.geom
      FROM geotools.roads  l
        JOIN geotools.nodes s ON  st_dwithin(l.geom,s.geom,1) and st_dwithin(st_startpoint(l.geom),s.geom,0.0001) and s.node_type in( 'rd','pole' , 'rd_line')
        JOIN geotools.nodes e ON  st_dwithin(l.geom,e.geom,1) and st_dwithin(st_endpoint(l.geom),e.geom,0.0001) and e.node_type in( 'rd' ,'pole', 'rd_line')
       and l.loc @> ARRAY[in_loc]

  )
    , q_edge_insert AS (
    INSERT INTO geotools.master_edge_table
    ( cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev, geom)
      SELECT *
      FROM q40
    RETURNING 1 cnt
  )
  SELECT count(cnt)
  INTO rt_val
  FROM q_edge_insert;

  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';

--#############################

--#############################
CREATE OR REPLACE FUNCTION geotools.insert_rd_line_to_common_edges(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  rt_val BIGINT :=0;
BEGIN
  DELETE FROM geotools.master_edge_table met
  WHERE met.loc = in_loc AND met.rev = in_rev AND met.src_trgt_type = 'rd_line_to_common';

     with  q40 AS (
      SELECT
        'unk' cl_id,
        n.objectid source,
        0 target,
        0 dist,
        0 "cost",
        1 cost_mult,
        'rd_line_to_common' src_trgt_type,
        in_loc loc,
        in_rev rev

      FROM   geotools.nodes n
         WHERE n.node_type= 'rd_line'
           and n.rev=in_rev and n.loc=in_loc

  )
    , q_edge_insert AS (
    INSERT INTO geotools.master_edge_table
    (  cl_id, source, target, dist, "cost", cost_mult, src_trgt_type, loc, rev)
      SELECT *
      FROM q40
    RETURNING 1 cnt
  )
  SELECT count(cnt)
  INTO rt_val
  FROM q_edge_insert;

  RETURN rt_val;

END;

$$ LANGUAGE 'plpgsql';

--#############################
CREATE OR REPLACE FUNCTION geotools.insert_lv_new_lines(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  ret_val BIGINT :=0;
BEGIN
DELETE FROM geotools.new_lines
WHERE loc = in_loc AND rev = in_rev;
  UPDATE geotools.master_edge_table set cost_mult= 1 where cost_mult<=0.01;
  WITH q10 AS (
      SELECT (pgr_dijkstra(
          'SELECT objectid id, source, target, cost::BIGINT  FROM geotools.master_edge_table where cl_id=''' || cl.cl_id
          ||
          '''',
          (SELECT array_agg(objectid)
           FROM geotools.nodes n
           WHERE n.cl_id = cl.cl_id AND n.type = 'pole'),
          (SELECT objectid
           FROM geotools.nodes n
           WHERE n.cl_id = cl.cl_id AND n.type = 'tr_pole'),
          FALSE)).*
      FROM geotools.bldgs_cl cl
      WHERE cl.loc = in_loc AND cl.rev = in_rev
    --and cl.cl_id in ('')
  )
    , q20 AS (
      SELECT DISTINCT
        a.edge id,
        b.source,
        b.target,
        b.cl_id,
        b.dist,
        b."cost",
        'lv'   v_level,
        b.src_trgt_type,
        in_loc loc,
        in_rev rev,
        b.geom
      FROM q10 a
        JOIN geotools.master_edge_table b ON a.edge = b.objectid
  )
        , q_insert AS (
        INSERT INTO geotools.new_lines
        (objectid, source, target, cl_id, dist, "cost", v_level, src_trgt_type, loc, rev, geom)
          SELECT *
          FROM q20
        RETURNING *)
    , q_update as(
      UPDATE geotools.master_edge_table met set cost_mult=0
      from q_insert where met.objectid=q_insert.objectid
  returning 1
  )
  SELECT count(*) into ret_val from q_update;

  RETURN ret_val;
END;

$$ LANGUAGE 'plpgsql';



--*************************************************************************
CREATE OR REPLACE FUNCTION geotools.insert_lv_new_lines_2(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  ret_val BIGINT :=0;
  tr_node geotools.NODES;
  in_node geotools.NODES;
  t_sources BIGINT[];
  t_targets BIGINT[];
  ar_node_ids BIGINT[]:=ARRAY[0];
  in_cl   geotools.BLDGS_CL;
BEGIN
  DELETE FROM geotools.new_lines
  WHERE loc = in_loc AND rev = in_rev;

  UPDATE geotools.master_edge_table set cost_mult= 1 where cost_mult<=0.01;

  FOR in_cl IN SELECT *
               FROM geotools.bldgs_cl
               WHERE rev = in_rev AND loc = in_loc --and cl_id='MASAKA-26_kVA_30kWh-475-1'
  LOOP
    SELECT *
    INTO tr_node
    FROM geotools.nodes
    WHERE cl_id = in_cl.cl_id AND node_type= 'tr_pole';

    FOR in_node IN
      SELECT *
      FROM geotools.nodes n
      WHERE n.cl_id = in_cl.cl_id AND n.node_type = 'pole'
      ORDER BY ST_Distance(tr_node.geom, geom) ASC
    LOOP
          if not (ar_node_ids && ARRAY[in_node.objectid]) then
        WITH q10 AS (
              SELECT (pgr_bdDijkstra(
                  'SELECT objectid id, source, target, ("cost"*cost_mult)::BIGINT "cost" FROM geotools.master_edge_table where cl_id=''' ||
                  in_cl.cl_id || '''',
                   in_node.objectid,
                   tr_node.objectid,
                  FALSE)).*
          )
            , q20 AS (
              SELECT DISTINCT
                a.edge id,
                b.source,
                b.target,
                b.cl_id,
                b.dist,
                b."cost",
                'lv'   v_level,
                b.src_trgt_type,
                in_loc loc,
                in_rev rev,
                b.geom
              FROM q10 a
                JOIN geotools.master_edge_table b ON a.edge = b.objectid
          where cost_mult>0
          )
            , q_insert AS (
            INSERT INTO geotools.new_lines
            (objectid, source, target, cl_id, dist, "cost", v_level, src_trgt_type, loc, rev, geom)
              SELECT *
              FROM q20
            RETURNING *)
           ,q_update as (
             UPDATE geotools.master_edge_table met set cost_mult=0
              from q_insert where met.objectid=q_insert.objectid
        )
          select array_agg(source), array_agg(target) into t_sources,t_targets from q_insert;

         ar_node_ids=ar_node_ids||t_sources||t_targets;
          --SELECT DISTINCT a.* INTO ar_node_ids from unnest(ar_node_ids) a;
        END IF ;
    END LOOP;

  END LOOP;


  RETURN ret_val;
END;

$$ LANGUAGE 'plpgsql';


--#############################
CREATE OR REPLACE FUNCTION geotools.insert_mv_new_lines(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  ret_val BIGINT :=0;
BEGIN
DELETE FROM geotools.new_lines
WHERE loc = in_loc AND rev = in_rev and  v_level='mv';

  WITH q10 AS (
      SELECT (pgr_dijkstra(
          'SELECT objectid id, source, target, (cost_mult*dist)::BIGINT "cost" ' ||
          'FROM geotools.master_edge_table ' ||
          'where (  cost_mult=0  or cl_id='unk' or src_trgt_type = ''rd_to_rd'' ) ' ||
          'and ( loc = '''|| in_loc ||''' AND rev = '''|| in_rev || ''' )',
          array_agg(n.objectid) ,
           0,
          FALSE)).*
      FROM geotools.nodes n
      WHERE   n.type = 'tr_pole'
            and n.loc = in_loc AND n.rev = in_rev
           -- and n.cl_id in ('MASAKA-26_kVA_30kWh-300-9')
  )
    , q20 AS (
      SELECT DISTINCT
        b.source,
        b.target,
        b.cl_id,
        b.dist,
        b."cost",
        'mv'   v_level,
        b.src_trgt_type,
        in_loc loc,
        in_rev rev,
        b.geom
      FROM q10 a
        JOIN geotools.master_edge_table b ON a.edge = b.objectid
  )
    , q_insert AS (
    INSERT INTO geotools.new_lines
    ( source, target, cl_id, dist, "cost", v_level, src_trgt_type, loc, rev, geom)
      SELECT *
      FROM q20
    RETURNING 1)
  SELECT count(*)
  INTO ret_val
  FROM q_insert;
  RETURN ret_val;
END;

$$ LANGUAGE 'plpgsql';

--*************************************************************************
CREATE OR REPLACE FUNCTION geotools.insert_mv_new_lines_2(in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
$$
DECLARE
  ret_val BIGINT :=0;
  in_node BIGINT ;
  tr_node geotools.NODES;
  t_sources BIGINT [];
  t_targets  BIGINT [];
  ar_node_ids BIGINT[]:=ARRAY[0] ;
BEGIN
DELETE FROM geotools.new_lines
WHERE loc = in_loc AND rev = in_rev and  v_level='mv';

  UPDATE geotools.master_edge_table set cost_mult= 1 where cost_mult=0.001;


    FOR in_node IN
      SELECT objectid FROM (
        SELECT n.objectid,
          row_number() OVER (PARTITION BY n.objectid ORDER BY n.geom<->src.geom ASC ) rnk,
          n.geom<->src.geom dist
        FROM geotools.nodes n, geotools.nodes src
        WHERE   n.node_type = 'tr_pole' and src.node_type = 'rd_line'
              and n.loc = in_loc AND n.rev = in_rev and src.loc = in_loc AND src.rev = in_rev
        ) n
      WHERE n.rnk=1
      ORDER BY dist ASC
    LOOP
      RAISE NOTICE 'in_node % ---------------------------',in_node;
  --  if not (1=1) then --ar_node_ids && ARRAY[in_node]
      WITH q10 AS (
          SELECT (pgr_dijkstra(
          'SELECT objectid id, source, target, (cost_mult*dist)::BIGINT "cost" ' ||
          'FROM geotools.master_edge_table ' ||
          'where (  cost_mult<=0.001  or cl_id=''unk'' or src_trgt_type = ''rd_to_rd'' ) ' ||
          'and ( loc = '''|| in_loc ||''' AND rev = '''|| in_rev || ''' )',
          in_node ,
           0,
          FALSE)).*
      )
        , q20 AS (
          SELECT DISTINCT
            a.edge objectid,
            b.source,
            b.target,
            b.cl_id,
            b.dist,
            b."cost",
            'mv'   v_level,
            b.src_trgt_type,
            in_loc loc,
            in_rev rev,
            b.geom
          FROM q10 a
            JOIN geotools.master_edge_table b ON a.edge = b.objectid
      where cost_mult<>0.001
      )
        , q_insert AS (
        INSERT INTO geotools.new_lines
        ( source, target, cl_id, dist, "cost", v_level, src_trgt_type, loc, rev, geom)
          SELECT  source, target, cl_id, dist, "cost", v_level, src_trgt_type, loc, rev, geom
          FROM q20)
      , q_update as(
      UPDATE geotools.master_edge_table met set cost_mult=0.001
      from q20 where met.objectid=q20.objectid
      )
      select array_agg(source), array_agg(target) into t_sources,t_targets from q20;
--       RAISE NOTICE 't_sources %', t_sources;
--       RAISE NOTICE 't_targets %', t_targets;
      --   ar_node_ids=ar_node_ids||t_sources||t_targets;
          --SELECT DISTINCT a.* INTO ar_node_ids from unnest(ar_node_ids) a;
  --  end if;

    END LOOP;



  RETURN ret_val;
END;

$$ LANGUAGE 'plpgsql';

--*************************************************************************************
CREATE OR REPLACE FUNCTION geotools.set_tr_size(in_tr_sizes numeric[], in_tr_size_unit text, in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
  $$
  DECLARE
    rt_val BIGINT:=0;
  BEGIN
    WITH q10 as(
      SELECT unnest(in_tr_sizes) as ts
      )
    , q20 as (
           SELECT
        objectid,
        demand,
        ts,
        row_number() OVER (PARTITION BY objectid ORDER BY ts ASC ) rnk
        from geotools.bldgs_cl cl
          JOIN q10 tr on tr.ts > cl.demand
        WHERE rev=in_rev and loc=in_loc
      )
    , q_update as (
      UPDATE geotools.bldgs_cl cl SET  tr_size =  ts||' '||in_tr_size_unit
        from q20
        WHERE cl.objectid=q20.objectid and rnk=1
        RETURNING 1
        )
    SELECT count(*) into rt_val FROM q_update;
    RETURN rt_val;
  END;

  $$ LANGUAGE 'plpgsql';

--*************************************************************************************
CREATE OR REPLACE FUNCTION geotools.update_prj( in_loc TEXT, in_rev TEXT)
  RETURNS BIGINT AS
  $$
  DECLARE
    rt_val BIGINT:=0;
  BEGIN

WITH RECURSIVE q10 as (
  SELECT
    n.objectid n_objectid,
    l.objectid l_objectid,
    ARRAY[l.objectid ] l_ar_objectid,
    source,
    target
  from geotools.nodes n
  join geotools.new_lines l on l.source = n.objectid or l.target=n.objectid
    WHERE n.type='rd_line' and l.v_level='mv' and l.geom is NOT null
          and n.rev=in_rev and n.loc=in_loc
          and l.rev=in_rev and l.loc=in_loc
          --and n.objectid =797757
   )
  ,q_rec (n_objectid, l_objectid, l_ar_objectid, source, target)
as (
  SELECT n_objectid,src_geom, l_objectid, l_ar_objectid, source, target, geom FROM q10
  UNION all
    SELECT
    q_rec.n_objectid,
    l.objectid l_objectid,
    q_rec.l_ar_objectid || l.objectid l_ar_objectid,
    l.source,
    l.target
  from q_rec
  join geotools.new_lines l on
       (l.source = q_rec.source or l.target=q_rec.source
       or l.source = q_rec.target or l.target=q_rec.target)
       AND l.objectid<>q_rec.l_objectid and not l_ar_objectid && ARRAY[l.objectid ]

    WHERE  l.v_level='mv' and l.geom is NOT null
             and l.rev=in_rev and l.loc=in_loc
          -- and l.rev='26_kVA_30kWh' and l.loc='MASAKA'
    )

select * from q_rec;


    $$ LANGUAGE 'sql';

CREATE OR REPLACE FUNCTION cnt_row (s_name TEXT, t_name TEXT) RETURNS BIGINT
  AS $$
  DECLARE
    rt_val BIGINT;
  BEGIN
    EXECUTE format('select count(1) from %I.%I',s_name,t_name)
    INTO rt_val;
    RETURN rt_val;
  END;
  $$ LANGUAGE 'plpgsql';
--*****************************************************************************************************

CREATE OR REPLACE FUNCTION geotools.extend_line (in_geom geometry, in_len NUMERIC) RETURNS geometry
  AS $$
with q10 as (
    SELECT ST_StartPoint(in_geom) AS s, ST_EndPoint(in_geom) AS e)
  ,q20 as (
    SELECT s, e, ST_Azimuth(s,e) AS az_se, ST_Azimuth(e, s) AS az_es, ST_Distance(s,e) + in_len AS len
    FROM q10)
SELECT ST_MakeLine(ST_TRANSLATE(s, sin(az_se) * len, cos(az_se) *
                                                   len),ST_TRANSLATE(e,sin(az_es) * len, cos(az_es) * len))
FROM q20;
  $$ LANGUAGE 'sql' IMMUTABLE PARALLEL SAFE;



